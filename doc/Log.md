# 游戏背景与创意设定

🎮 **游戏背景设定：《断界之城》**

🌍 **世界观设定：**
在一个被称为「断界」的像素世界中，曾经是一个完整而和谐的大陆，但自从神秘的“切割仪式”失败后，大陆被划分为无数悬浮碎块，每一块都漂浮在虚空之中。大陆上的居民被迫居住在这些分裂的地块上，失去了彼此之间的联系。为了恢复大陆的完整，玩家将扮演一位「断界使者」，使用“多段切割”之力，通过精确的切割和连接，重新拼接世界的碎片。

🎨 **风格描述：**
- 像素风格：采用复古的16位像素风格，每块地形碎片像是悬浮在星空或虚空中的乐高积木。
- 悬浮地块：地图由碎块组成，切割这些碎块可以触发谜题、机关或战斗，拼接后通往下一关。
- 赛博+奇幻融合：古老的符文科技与蒸汽机械并存，画面中既有发光电路，也有神秘浮雕。

🔧 **游戏核心机制（结合Multicut）：**
玩家可以切割地形，将大型地图分割为更小的区域，用于：
- 隔离敌人或机关
- 解决谜题
- 建立传送连接

游戏目标是找出正确的“切割点”和“重组逻辑”，最终将碎片连接成一个完整图形或路径。

🎭 **故事背景：**
「神明赐予我们‘连接与分割’的力量，却也惩罚了我们的贪婪。当最后一次多段仪式失败后，世界崩裂了——不是破碎，而是被完美地划开……现在，只有断界使者，能用同样的力量将它重组。」

你作为最后的断界使者，踏上旅程，从最小的碎片开始，逐渐解锁世界的秘密，唤醒沉睡的遗迹与技术，将「断界」重新连接成一个完整的世界。

💡 **可能的场景示例：**
| 章节名     | 场景描述                                   | 新增机制                 |
|------------|--------------------------------------------|--------------------------|
| 裂痕村落   | 最初的碎片区域，教学关卡，村民被困在不同碎块中 | 基本切割与拼接机制       |
| 漂浮工厂   | 被蒸汽机械掌控的浮空岛，每切一次都会触发传送带与机关 | 机关连动，时序重组       |
| 镜面荒原   | 地形映射成镜像世界，切割后影响镜像的一侧     | 镜像同步与错位拼图       |
| 虚空深渊   | 在暗色背景中漂浮的碎片迷宫，必须通过切割开辟可行路径 | 重力扭转，地块旋转拼接   |
| 神殿核心   | 世界的核心控制室，必须恢复所有碎片通路来解锁最终仪式 | 多段并发切割，时间倒流机制 |

---

# TODO



# Done

1. 使用prefab预制体创建了cell模板
   - Q:字体放大不清晰
   - A:使用TEXTMESHPRO
2. 在GameManager使用脚本批量创建cells,
   - Q:会出现多个cell聚集到一个区域,多个重叠
   - A:检测距离是否过近(==泊松圆盘分布==)
3. 使用字典(cell,cell),(edge,weight)来映射边和点的数据结构
4. 使用Delaunay triangulation创建网格图
   - Q:
     ![image-20250602221013088](https://raw.githubusercontent.com/stingo1218/pic/main/Typoraimage-20250602221013088.png)
   - A:(进行度数检查防止度数差异过大)/ 或者角度过小进行删去
5. eraseline的设计,用户可以按住右键使用切割线,线会切断经过的edges(如果这是规则允许的),也可以重新连回来
6. 重新连接:两个隔离的连通分量当被一条线连接时,如果成为了新的一个连通分量,那么就会检查初始的edges,进行重新连接
7. > - Inspector多选算法：支持选择多割算法（目前只有贪心算法）。
   >
   > - 贪心多割算法实现：初版为最大割，后修正为最小割（优先移除权重最小的边）。
   >
   > - 高亮切割边：实现了高亮显示需要切割的边（可用深红色或高亮材质）。
   >
   > - 关卡自适应缩放居中：生成点后自动缩放并居中，保证关卡适配全屏。
   >
   > - 修正连线错位问题：调整生成顺序，先归一化点再连线，保证线和点一致。
   >
   > - HINT按钮触发：将多割算法的执行逻辑移到点击HINT按钮时触发，只有需要提示时才高亮显示最佳切割边。

8. **Delaunay Refinement细分法集成** (2024-12-19)
   - **问题**：Delaunay三角剖分产生矮胖三角形，影响可视化和游戏体验
   - **解决方案**：集成Delaunay Refinement算法，自动检测并改善三角形质量
   - **实现细节**：
     - 计算三角形最小高/最长边比，识别不合格三角形
     - 在坏三角形外心插入新点，重新剖分
     - 循环迭代直到所有三角形满足质量要求或达到最大迭代次数
   - **参数设置**：`minHeightToEdgeRatio = 0.2f`，`maxRefineIters = 10`
   - **边界处理**：过滤细分插入点对应的边，避免索引越界

9. **标准多割算法实现** (2024-12-19)
   - **问题**：原算法限制连通分量数量，不符合标准多割问题定义
   - **解决方案**：修改为真正的标准多割问题，不限制连通分量数量
   - **算法改进**：
     - **ILP算法**：移除连通分量数量约束，使用循环不等式约束
     - **贪心算法**：移除连通分量数量目标，使用循环不等式检查
     - **目标函数**：最大化保留边的权重和（使用正数权重）

10. **权重系统优化** (2024-12-19)
    - **问题分析**：负数权重导致"全切"，正数权重导致"不切"
    - **解决方案**：使用正数权重 + 最大化目标函数
    - **权重含义**：权重越大表示边越重要，越不应该被切割
    - **算法行为**：
      - 保留重要的边（权重大的）
      - 切割不重要的边（权重小的）
      - 在满足循环不等式约束的前提下优化

11. **游戏设计优化** (2024-12-19)
    - **权重可视化建议**：根据权重设置边的视觉效果（粗细、颜色）
    - **玩家引导**：权重越大越重要，切割重要边时给出警告
    - **策略深度**：玩家需要权衡哪些边可以安全切割

12. **2024-06-13 UI与功能重构**
    - Hint按钮彻底切换为Toggle预制体，支持开关切换和高亮切割边，原Button相关逻辑全部移除。
    - HintToggle功能完善，支持动态高亮/取消高亮。
    - 代码冗余清理，删除isHintButtonPressed等无用变量。
    - UI适配，HintToggle可自定义大小，支持放置到任意Canvas。
    - 其它细节优化。

13. **2024-06-13 Unity中采用Python脚本调用Gurobi的原因说明**
   - **背景**：多割问题（Multicut/K-way Cut）属于NP难问题，最优解通常依赖数学优化工具如Gurobi等求解器。
   - **Unity集成难点**：
     - Gurobi官方C# API仅支持Windows且依赖复杂，Unity工程跨平台（如Mac、Linux、WebGL）时兼容性差。
     - Unity C#环境与Gurobi C# API集成时，DLL加载、授权、依赖管理等问题繁琐，易出错。
     - Unity工程热更、打包等流程下，C#原生调用Gurobi不易维护。
   - **Python方案优势**：
     - Gurobi官方对Python支持极佳，安装和调用简单，社区资料丰富。
     - Python脚本可独立于Unity运行，易于调试和快速迭代算法。
     - 通过文件（input.json/output.json）或进程通信，Unity与Python解耦，便于后续算法升级和跨平台兼容。
   - **具体实现**：
     - Unity C#端将图结构和权重序列化为JSON，写入input.json。
     - 调用Python脚本（multicut_solver.py），由其负责Gurobi建模与求解。
     - Python输出最优切割边和cost到output.json，Unity再读取并高亮显示。
   - **经验总结**：
     - 采用Python脚本调用Gurobi极大提升了开发效率和算法灵活性，规避了Unity与Gurobi直接集成的兼容性和维护难题。

14. **2024-06-13 多割高亮只显示一条边问题排查与解决**
   - **问题现象**：Python输出的output.json中cut_edges有多条边，但Unity只高亮了一条（如只高亮4-3，未高亮4-1、4-2等）。
   - **原因分析**：C#端解析output.json时采用字符串分割方式，遇到多条边、换行、空格等格式变化时，分割逻辑失效，导致只解析到一条或部分边。
   - **调试过程**：
     - 在HighlightCutEdges方法中加入UnityEngine.Debug.Log，打印cutEdges的内容，发现只传入了一条边。
     - 检查output.json内容，确认cut_edges为标准JSON数组格式。
     - 进一步分析发现，手动字符串分割方式不适合解析标准JSON数组，容易遗漏多条边。
   - **最终解决方案**：
     - 推荐使用Unity的JsonUtility或Newtonsoft.Json（Json.NET）直接反序列化output.json，保证所有cut_edges都能被正确读取。
     - 关键代码建议：
       ```csharp
       [Serializable]
       public class CutEdge { public int u; public int v; }
       [Serializable]
       public class MulticutResult { public List<CutEdge> cut_edges; public int cost; }
       // 解析
       var result = JsonUtility.FromJson<MulticutResult>(resultJson);
       var cutEdges = new List<(Cell, Cell)>();
       if (result != null && result.cut_edges != null)
       {
           foreach (var edge in result.cut_edges)
           {
               var cellU = _cells.FirstOrDefault(c => c.Number == edge.u);
               var cellV = _cells.FirstOrDefault(c => c.Number == edge.v);
               if (cellU != null && cellV != null)
                   cutEdges.Add(GetCanonicalEdgeKey(cellU, cellV));
           }
       }
       ```
   - **经验总结**：解析标准JSON时应避免手动字符串分割，优先使用官方或第三方JSON库，提升健壮性和可维护性。


---

### 2024-06-13 多割算法与关卡设计问题记录

1. **output.json多条边只高亮一条问题**
   - **问题现象**：Python输出的cut_edges有多条，但Unity只高亮了一条。
   - **原因分析**：C#解析output.json时用字符串分割，遇到换行/空格等格式变化时只解析到一条。
   - **解决方案**：改用正则表达式批量提取所有cut_edges，保证无论格式如何都能全部解析。
   - **正则示例**：`@"\{\s*\"u\"\s*:\s*(\d+)\s*,\s*\"v\"\s*:\s*(\d+)\s*\}"`

2. **多割算法遇到无可优化空间的关卡**
   - **问题现象**：有些关卡output.json的cut_edges为空，玩家无事可做。
   - **原因分析**：标准多割算法下，若图结构和权重分布没有"冲突"或"优化空间"，算法会返回空解。
   - **解决方案**：
     - 关卡生成后自动检测cut_edges是否为空，若为空提示设计师调整结构或权重。
     - 设计时增加环路、负权重边等，制造"可优化空间"。

3. **当前cost未实时更新问题**
   - **问题现象**：UI上COST左侧数字（当前cost）不随玩家切割实时变化。
   - **原因分析**：原实现统计的是高亮材质的边，而不是玩家实际切割的边。
   - **解决方案**：
     - 新增playerCutEdges集合，记录玩家每次实际切割的边。
     - RemoveEdge时加入集合并刷新UI。
     - GetCurrentCost统计playerCutEdges的权重和。
     - 关卡重置时清空集合。

4. **UI中CostText的自动刷新与格式规范**
   - **问题现象**：最优cost能更新，当前cost不变或格式不统一。
   - **解决方案**：
     - 每次切割后自动调用UpdateCostText，格式为`COST: 当前cost/最优cost`。
     - 解析output.json时同步提取cost字段。
     - 关卡重置、Hint关闭等场景也刷新一次。



