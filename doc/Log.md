# 游戏背景与创意设定

🎮 **游戏背景设定：《断界之城》**

🌍 **世界观设定：**
在一个被称为「断界」的像素世界中，曾经是一个完整而和谐的大陆，但自从神秘的“切割仪式”失败后，大陆被划分为无数悬浮碎块，每一块都漂浮在虚空之中。大陆上的居民被迫居住在这些分裂的地块上，失去了彼此之间的联系。为了恢复大陆的完整，玩家将扮演一位「断界使者」，使用“多段切割”之力，通过精确的切割和连接，重新拼接世界的碎片。

🎨 **风格描述：**
- 像素风格：采用复古的16位像素风格，每块地形碎片像是悬浮在星空或虚空中的乐高积木。
- 悬浮地块：地图由碎块组成，切割这些碎块可以触发谜题、机关或战斗，拼接后通往下一关。
- 赛博+奇幻融合：古老的符文科技与蒸汽机械并存，画面中既有发光电路，也有神秘浮雕。

🔧 **游戏核心机制（结合Multicut）：**
玩家可以切割地形，将大型地图分割为更小的区域，用于：
- 隔离敌人或机关
- 解决谜题
- 建立传送连接

游戏目标是找出正确的“切割点”和“重组逻辑”，最终将碎片连接成一个完整图形或路径。

🎭 **故事背景：**
「神明赐予我们‘连接与分割’的力量，却也惩罚了我们的贪婪。当最后一次多段仪式失败后，世界崩裂了——不是破碎，而是被完美地划开……现在，只有断界使者，能用同样的力量将它重组。」

你作为最后的断界使者，踏上旅程，从最小的碎片开始，逐渐解锁世界的秘密，唤醒沉睡的遗迹与技术，将「断界」重新连接成一个完整的世界。

💡 **可能的场景示例：**
| 章节名     | 场景描述                                   | 新增机制                 |
|------------|--------------------------------------------|--------------------------|
| 裂痕村落   | 最初的碎片区域，教学关卡，村民被困在不同碎块中 | 基本切割与拼接机制       |
| 漂浮工厂   | 被蒸汽机械掌控的浮空岛，每切一次都会触发传送带与机关 | 机关连动，时序重组       |
| 镜面荒原   | 地形映射成镜像世界，切割后影响镜像的一侧     | 镜像同步与错位拼图       |
| 虚空深渊   | 在暗色背景中漂浮的碎片迷宫，必须通过切割开辟可行路径 | 重力扭转，地块旋转拼接   |
| 神殿核心   | 世界的核心控制室，必须恢复所有碎片通路来解锁最终仪式 | 多段并发切割，时间倒流机制 |

---

# TODO



# Done

1. 使用prefab预制体创建了cell模板
   - Q:字体放大不清晰
   - A:使用TEXTMESHPRO
2. 在GameManager使用脚本批量创建cells,
   - Q:会出现多个cell聚集到一个区域,多个重叠
   - A:检测距离是否过近(==泊松圆盘分布==)
3. 使用字典(cell,cell),(edge,weight)来映射边和点的数据结构
4. 使用Delaunay triangulation创建网格图
   - Q:
     ![image-20250602221013088](https://raw.githubusercontent.com/stingo1218/pic/main/Typoraimage-20250602221013088.png)
   - A:(进行度数检查防止度数差异过大)/ 或者角度过小进行删去
5. eraseline的设计,用户可以按住右键使用切割线,线会切断经过的edges(如果这是规则允许的),也可以重新连回来
6. 重新连接:两个隔离的连通分量当被一条线连接时,如果成为了新的一个连通分量,那么就会检查初始的edges,进行重新连接
7. > - Inspector多选算法：支持选择多割算法（目前只有贪心算法）。
   >
   > - 贪心多割算法实现：初版为最大割，后修正为最小割（优先移除权重最小的边）。
   >
   > - 高亮切割边：实现了高亮显示需要切割的边（可用深红色或高亮材质）。
   >
   > - 关卡自适应缩放居中：生成点后自动缩放并居中，保证关卡适配全屏。
   >
   > - 修正连线错位问题：调整生成顺序，先归一化点再连线，保证线和点一致。
   >
   > - HINT按钮触发：将多割算法的执行逻辑移到点击HINT按钮时触发，只有需要提示时才高亮显示最佳切割边。

8. **Delaunay Refinement细分法集成** (2024-12-19)
   - **问题**：Delaunay三角剖分产生矮胖三角形，影响可视化和游戏体验
   - **解决方案**：集成Delaunay Refinement算法，自动检测并改善三角形质量
   - **实现细节**：
     - 计算三角形最小高/最长边比，识别不合格三角形
     - 在坏三角形外心插入新点，重新剖分
     - 循环迭代直到所有三角形满足质量要求或达到最大迭代次数
   - **参数设置**：`minHeightToEdgeRatio = 0.2f`，`maxRefineIters = 10`
   - **边界处理**：过滤细分插入点对应的边，避免索引越界

9. **标准多割算法实现** (2024-12-19)
   - **问题**：原算法限制连通分量数量，不符合标准多割问题定义
   - **解决方案**：修改为真正的标准多割问题，不限制连通分量数量
   - **算法改进**：
     - **ILP算法**：移除连通分量数量约束，使用循环不等式约束
     - **贪心算法**：移除连通分量数量目标，使用循环不等式检查
     - **目标函数**：最大化保留边的权重和（使用正数权重）

10. **权重系统优化** (2024-12-19)
    - **问题分析**：负数权重导致"全切"，正数权重导致"不切"
    - **解决方案**：使用正数权重 + 最大化目标函数
    - **权重含义**：权重越大表示边越重要，越不应该被切割
    - **算法行为**：
      - 保留重要的边（权重大的）
      - 切割不重要的边（权重小的）
      - 在满足循环不等式约束的前提下优化

11. **游戏设计优化** (2024-12-19)
    - **权重可视化建议**：根据权重设置边的视觉效果（粗细、颜色）
    - **玩家引导**：权重越大越重要，切割重要边时给出警告
    - **策略深度**：玩家需要权衡哪些边可以安全切割

12. **2024-06-13 UI与功能重构**
    - Hint按钮彻底切换为Toggle预制体，支持开关切换和高亮切割边，原Button相关逻辑全部移除。
    - HintToggle功能完善，支持动态高亮/取消高亮。
    - 代码冗余清理，删除isHintButtonPressed等无用变量。
    - UI适配，HintToggle可自定义大小，支持放置到任意Canvas。
    - 其它细节优化。

13. **2024-06-13 Unity中采用Python脚本调用Gurobi的原因说明**
   - **背景**：多割问题（Multicut/K-way Cut）属于NP难问题，最优解通常依赖数学优化工具如Gurobi等求解器。
   - **Unity集成难点**：
     - Gurobi官方C# API仅支持Windows且依赖复杂，Unity工程跨平台（如Mac、Linux、WebGL）时兼容性差。
     - Unity C#环境与Gurobi C# API集成时，DLL加载、授权、依赖管理等问题繁琐，易出错。
     - Unity工程热更、打包等流程下，C#原生调用Gurobi不易维护。
   - **Python方案优势**：
     - Gurobi官方对Python支持极佳，安装和调用简单，社区资料丰富。
     - Python脚本可独立于Unity运行，易于调试和快速迭代算法。
     - 通过文件（input.json/output.json）或进程通信，Unity与Python解耦，便于后续算法升级和跨平台兼容。
   - **具体实现**：
     - Unity C#端将图结构和权重序列化为JSON，写入input.json。
     - 调用Python脚本（multicut_solver.py），由其负责Gurobi建模与求解。
     - Python输出最优切割边和cost到output.json，Unity再读取并高亮显示。
   - **经验总结**：
     - 采用Python脚本调用Gurobi极大提升了开发效率和算法灵活性，规避了Unity与Gurobi直接集成的兼容性和维护难题。

14. **2024-06-13 多割高亮只显示一条边问题排查与解决**
   - **问题现象**：Python输出的output.json中cut_edges有多条边，但Unity只高亮了一条（如只高亮4-3，未高亮4-1、4-2等）。
   - **原因分析**：C#端解析output.json时采用字符串分割方式，遇到多条边、换行、空格等格式变化时，分割逻辑失效，导致只解析到一条或部分边。
   - **调试过程**：
     - 在HighlightCutEdges方法中加入UnityEngine.Debug.Log，打印cutEdges的内容，发现只传入了一条边。
     - 检查output.json内容，确认cut_edges为标准JSON数组格式。
     - 进一步分析发现，手动字符串分割方式不适合解析标准JSON数组，容易遗漏多条边。
   - **最终解决方案**：
     - 推荐使用Unity的JsonUtility或Newtonsoft.Json（Json.NET）直接反序列化output.json，保证所有cut_edges都能被正确读取。
     - 关键代码建议：
       ```csharp
       [Serializable]
       public class CutEdge { public int u; public int v; }
       [Serializable]
       public class MulticutResult { public List<CutEdge> cut_edges; public int cost; }
       // 解析
       var result = JsonUtility.FromJson<MulticutResult>(resultJson);
       var cutEdges = new List<(Cell, Cell)>();
       if (result != null && result.cut_edges != null)
       {
           foreach (var edge in result.cut_edges)
           {
               var cellU = _cells.FirstOrDefault(c => c.Number == edge.u);
               var cellV = _cells.FirstOrDefault(c => c.Number == edge.v);
               if (cellU != null && cellV != null)
                   cutEdges.Add(GetCanonicalEdgeKey(cellU, cellV));
           }
       }
       ```
   - **经验总结**：解析标准JSON时应避免手动字符串分割，优先使用官方或第三方JSON库，提升健壮性和可维护性。


---

### 2024-06-13 多割算法与关卡设计问题记录

1. **output.json多条边只高亮一条问题**
   - **问题现象**：Python输出的cut_edges有多条，但Unity只高亮了一条。
   - **原因分析**：C#解析output.json时用字符串分割，遇到换行/空格等格式变化时只解析到一条。
   - **解决方案**：改用正则表达式批量提取所有cut_edges，保证无论格式如何都能全部解析。
   - **正则示例**：`@"\{\s*\"u\"\s*:\s*(\d+)\s*,\s*\"v\"\s*:\s*(\d+)\s*\}"`

2. **多割算法遇到无可优化空间的关卡**
   - **问题现象**：有些关卡output.json的cut_edges为空，玩家无事可做。
   - **原因分析**：标准多割算法下，若图结构和权重分布没有"冲突"或"优化空间"，算法会返回空解。
   - **解决方案**：
     - 关卡生成后自动检测cut_edges是否为空，若为空提示设计师调整结构或权重。
     - 设计时增加环路、负权重边等，制造"可优化空间"。

3. **当前cost未实时更新问题**
   - **问题现象**：UI上COST左侧数字（当前cost）不随玩家切割实时变化。
   - **原因分析**：原实现统计的是高亮材质的边，而不是玩家实际切割的边。
   - **解决方案**：
     - 新增playerCutEdges集合，记录玩家每次实际切割的边。
     - RemoveEdge时加入集合并刷新UI。
     - GetCurrentCost统计playerCutEdges的权重和。
     - 关卡重置时清空集合。

4. **UI中CostText的自动刷新与格式规范**
   - **问题现象**：最优cost能更新，当前cost不变或格式不统一。
   - **解决方案**：
     - 每次切割后自动调用UpdateCostText，格式为`COST: 当前cost/最优cost`。
     - 解析output.json时同步提取cost字段。
     - 关卡重置、Hint关闭等场景也刷新一次。

---

### 2024-12-20 地形系统与图论算法集成

15. **六边形地形生成系统详细实现**
    - **地形生成流程**：
      1. **六边形网格生成**：使用HexCoordinateSystem生成平顶六边形网格，支持自定义行列数
      2. **Perlin噪声地形**：
         - **海拔图生成**：使用多层Perlin噪声叠加，模拟真实地形起伏
         - **湿度图生成**：独立的Perlin噪声层，控制地区干湿程度
         - **岛屿形状**：使用距离衰减函数，确保地图边缘为海洋
         - **噪声参数**：可调节频率、振幅、种子值，支持多种地形风格
      3. **生物群系映射**：
         - 基于海拔和湿度的二维映射决定生物群系类型
         - 包含草地、平原、森林、山地、沙漠、水域等多种地形
         - 支持特殊地形：火山（高海拔+低湿度）、沼泽（低海拔+高湿度）
      4. **河流生成系统**：
         - 从高海拔向低海拔流淌，模拟真实水文
         - 支持河流汇聚和分叉，形成复杂水系网络
         - 河流瓦片单独渲染，可与地形瓦片叠加显示

    - **地形渲染技术**：
      - **Tilemap渲染**：使用Unity Tilemap系统，支持大规模地形高效渲染
      - **Sprite切片技术**：将地形贴图自动切片为16x16瓦片，支持无缝拼接
      - **双层渲染**：地形层+河流层分离渲染，支持独立控制和特效
      - **实时预览**：支持参数调整后实时重新生成，便于关卡设计

    - **核心算法技术细节**：
      - **Perlin噪声算法改进**：
        ```csharp
        // 从JavaScript SimplexNoise移植到Unity Perlin噪声
        // 关键修复：输出范围从[0,1]转换为[-1,1]
        float e = Mathf.PerlinNoise(x + offsetX, y + offsetY) * 2.0f - 1.0f;
        // 使用种子生成随机偏移，确保可重现性
        offsetX = new System.Random(settings.seed).Next(-1000, 1000);
        ```
      - **岛屿形状生成**：
        ```csharp
        // 使用欧几里得距离衰减，模拟岛屿边缘
        float distance = Mathf.Sqrt((xp - 0.5f) * (xp - 0.5f) + (yp - 0.5f) * (yp - 0.5f));
        e = (1.0f + e - distance * 2.2f) / 2.0f; // 边缘衰减公式
        ```
      - **生物群系决策树**：
        ```csharp
        // 基于海拔和湿度的二维分类
        if (elevation < 0.1f) return BiomeType.DeepWater;
        if (elevation < 0.2f) return BiomeType.ShallowWater;
        if (elevation > 0.8f && moisture < 0.3f) return BiomeType.Volcano;
        if (elevation > 0.6f) return BiomeType.Mountain;
        // ... 更多分类规则
        ```

    - **地形数据结构**：
      - **HexTile数据结构**：包含坐标、海拔、湿度、生物群系、河流状态等完整信息
      - **TerrainSettings序列化**：支持Map Hash功能，可导出/导入地形配置
      - **坐标系统**：六边形坐标(q,r)与Unity世界坐标的双向转换
      - **边界处理**：自动计算地形边界，支持相机自适应和节点采样范围

    - **关键技术问题与解决方案**：
      - **坐标系统修正**：
        - **问题**：地形显示为20x47而非预期的47x20（行列颠倒）
        - **根因**：六边形坐标到Tilemap坐标的映射错误
        - **解决**：修正`ConvertHexToTilePosition`中q/r坐标映射关系
        ```csharp
        // 修正前：错误的坐标映射
        return new Vector3Int(hex.coord.r, hex.coord.q, 0);
        // 修正后：正确的坐标映射  
        return new Vector3Int(hex.coord.q, hex.coord.r, 0);
        ```
      - **噪声算法移植**：
        - **问题**：Unity Perlin噪声与JavaScript SimplexNoise结果差异巨大
        - **解决**：添加种子偏移、修正输出范围、匹配边界处理逻辑
      - **Sprite管理系统**：
        - **问题**：动态创建Sprite导致性能问题和"映射字典未初始化"警告
        - **解决**：改用预切片Sprite + 字典映射，支持自动导入和手动覆盖

    - **Map Hash序列化系统**：
      - **功能**：将TerrainSettings序列化为Base64编码的JSON字符串
      - **用途**：分享地形配置、保存特定地图、快速切换测试参数
      - **实现**：
        ```csharp
        public string ToMapHash() {
            string json = JsonUtility.ToJson(this);
            return System.Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(json));
        }
        ```
      - **集成**：TerrainManager提供导出/导入/剪贴板操作的上下文菜单

    - **核心算法数学原理简述**：

      **1. 六边形坐标系统算法**：
      使用轴坐标(q,r)表示平顶六边形，通过数学变换公式在世界坐标与六边形坐标间转换。主要解决像素拾取和瓦片定位问题，使用舍入算法处理浮点坐标到整数坐标的转换。

      **2. Perlin噪声多层合成算法（分频噪声）**：
      基于Fractal Brownian Motion（分形布朗运动）原理，将多层不同频率和振幅的Perlin噪声叠加。每层使用persistence（持续性，通常0.5）控制振幅衰减，lacunarity（间隙性，通常2.0）控制频率增长，最终归一化并转换到合适的高程范围。

      **3. 岛屿形状生成算法**：
      使用多种距离函数创建不同形状的岛屿边界：欧几里得距离产生圆形，曼哈顿距离产生菱形，切比雪夫距离产生方形。通过SmoothStep平滑衰减函数避免硬边界，与高程数据相乘形成自然的岛屿形状。

      **4. 生物群系分类算法（决策树）**：
      基于Whittaker生物群系图的二维分类系统，使用海拔和湿度作为输入。按优先级进行层次判定：水域优先，然后极端地形（雪山、火山），最后基于湿度梯度分类平地生物群系。

      **5. 河流生成算法（流域模拟）**：
      模拟真实水流行为，从高海拔随机起点开始，使用贪心策略追踪最陡峭下降路径。通过梯度下降找到局部最低点，形成自然的河流网络。避免循环和死锁的访问控制机制。

      **6. 泊松圆盘采样算法（Bridson算法）**：
      快速生成均匀分布的点集，避免点聚集。使用背景网格加速距离查询，维护活跃点列表，在环形区域内尝试生成新点。采用Mitchell最佳候选算法优化采样质量，时间复杂度O(n)。

      **7. Delaunay三角剖分算法（Bowyer-Watson算法）**：
      增量式构建三角网格，保证所有三角形满足Delaunay条件（任何三角形的外接圆内不包含其他点）。逐点插入时删除违反条件的"坏三角形"，重新三角化形成的多边形洞。产生最优的三角网格拓扑。

      **8. 地形权重计算算法**：
      通过线段采样分析边经过的地形类型，沿线段等距采样获取穿越的生物群系。使用加权平均策略：最困难地形影响权重70%，平均难度影响30%，确保路径规划倾向于避开困难地形。

16. **TilemapGameManager地形图游戏管理器开发**
    - **目标**：将地形系统与图论多割算法结合，实现基于真实地形的策略游戏
    - **核心功能实现**：
      - **泊松圆盘采样**：在地形边界内智能生成节点，避免重叠，支持自定义采样密度
      - **Delaunay三角剖分**：自动连接节点生成最优拓扑结构，确保图的连通性
      - **地形感知权重系统**：根据边穿越的地形类型动态分配权重
        - 正权重地形（倾向保留）：草地(+5)、平原(+4)、浅水(+3)
        - 负权重地形（倾向切割）：深水(-8)、山地(-10)、高山(-15)、火山(-20)、森林(-6)、河流(-12)
      - **可视化权重**：边的颜色和粗细根据权重动态调整，直观显示重要性
      - **完整交互系统**：支持点击、拖拽创建边、右键擦除等操作

17. **Unity API兼容性修复**
    - **问题**：多个Unity API废弃警告和编译错误
    - **解决方案**：
      - `FindObjectOfType` → `FindObjectsByType(FindObjectsSortMode.None).FirstOrDefault()`
      - `LineRenderer.color` → `startColor/endColor` 分别设置
      - 修复Unity序列化断言错误，为动态创建的GameObject添加`HideFlags.DontSave`

18. **访问权限和架构优化**
    - **TerrainManager访问权限调整**：
      - `ConvertHexToTilePosition()` 方法改为public，供外部系统调用
      - 添加 `public Tilemap tilemap` 属性，提供对地形Tilemap的访问
      - 将私有 `hexTiles` 字段的访问统一使用 `GetHexTiles()` 方法
    - **代码架构改进**：统一使用公开方法访问内部数据，提高封装性

19. **Git版本控制与合并冲突处理**
    - **问题**：本地分支与远程分支发生分歧，包含多个文件的合并冲突
    - **解决过程**：
      - 手动解决TerrainManager.cs中的ContextMenu冲突，保留生成和清空地形功能
      - 处理plastic文件的二进制冲突，使用远程版本
      - 保留调试日志的注释状态，与远程保持一致
    - **成功合并**：保留了所有新功能的同时与远程分支同步

20. **TerrainManager上下文菜单功能恢复**
    - **需求**：恢复TerrainManager的右键菜单功能
    - **实现**：
      - 为 `GenerateTerrain()` 方法添加 `[ContextMenu("生成地形")]`
      - 为 `ClearGeneratedTerrain()` 方法添加 `[ContextMenu("清空地形")]`
      - 修复 `RegenerateTerrain()` 方法调用逻辑
    - **结果**：用户可以通过右键点击组件快速执行地形操作

21. **地形权重算法设计**
    - **算法逻辑**：
      - 沿边线采样多个点，检查穿越的所有地形类型
      - 使用最小权重（最困难地形）和平均权重的加权组合
      - 公式：`finalWeight = 0.7 * minWeight + 0.3 * avgWeight`
    - **游戏意义**：
      - 多割算法会优先切割困难地形（负权重）的边
      - 保留易通行地形（正权重）的边
      - 最终结果倾向于保留平坦草地的连接，切除水域山脉的阻隔

22. **项目功能集成与测试准备**
    - **当前状态**：TilemapGameManager已完成开发，所有编译错误已修复
    - **待测试功能**：
      - 地形生成后自动节点生成
      - 不同地形类型的边权重分配
      - 泊松采样和Delaunay三角剖分效果验证
      - Python多割算法在地形权重下的最优解计算

23. **TilemapGameManager与GameManager集成开发** (2024-12-20)
    - **目标**：将TilemapGameManager的地形感知功能与GameManager的多割算法完全集成
    - **核心需求**：
      - **地形数据驱动**：使用真实地形数据替代随机生成的图结构
      - **地形权重系统**：根据边穿越的地形类型动态分配权重
        - 复杂地形（河流、山林、高山、火山）→ 负数权重 → 偏向切割
        - 简单地形（草地等）→ 正数权重 → 倾向于保留
      - **泊松分布采样**：在地形边界内智能生成节点，避免重叠
      - **Delaunay三角剖分**：连接节点形成最优拓扑结构
      - **多割算法优化**：让游戏的多割算法能够"感知"真实地形
    - **技术实现要点**：
      - 将地形数据与图论算法结合
      - 基于实际地形类型分配边权重
      - 优化多割算法在真实地形上的表现
      - 实现地形感知的路径规划
    - **预期效果**：让游戏更加直观，路径规划更符合真实地形特征



