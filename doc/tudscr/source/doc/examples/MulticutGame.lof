\babel@toc {english}{}\relax 
\babel@toc {english}{}\relax 
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces Multicut problem example: A 3Ã—4 grid graph showing cut edges (red dashed lines) and partitioned regions (light green areas). This example demonstrates the cycle inequality constraint.}}{9}{figure.caption.8}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces Terrain sprites collection showing diverse landscape elements including forests, mountains, water bodies, and urban areas designed for seamless hexagonal grid integration and procedural terrain generation.}}{14}{figure.caption.11}%
\contentsline {figure}{\numberline {4.2}{\ignorespaces Alliance Divider game interface showing hexagonal terrain, city-states, and UI elements including cost display, level information, and cut limit indicators.}}{16}{figure.caption.18}%
\contentsline {figure}{\numberline {4.3}{\ignorespaces Core data structures of the Multicut Game showing the Graph, Node, Edge, and Game State components and their relationships.}}{17}{figure.caption.19}%
\contentsline {figure}{\numberline {4.4}{\ignorespaces System architecture overview showing the seven-layer structure from Game Engine Layer to Visualization Layer, demonstrating the data flow and component interactions.}}{19}{figure.caption.28}%
\contentsline {figure}{\numberline {4.5}{\ignorespaces Six examples of procedurally generated terrain maps using the same parameters, demonstrating the random yet artistically pleasing visual effects of the TiledProceduralHexTerrainGenerator.}}{21}{figure.caption.37}%
\contentsline {figure}{\numberline {4.6}{\ignorespaces Coordinate system conversion diagram showing the transformation from hexagonal axial coordinates (q,r) to Unity world coordinates (x,y) and the mathematical relationships between different coordinate systems.}}{22}{figure.caption.40}%
\contentsline {figure}{\numberline {4.7}{\ignorespaces Unity-Python integration workflow showing the data flow from Unity through JSON files to Python and Gurobi solver, and back to Unity for game state updates.}}{24}{figure.caption.50}%
\contentsline {figure}{\numberline {4.8}{\ignorespaces Level generation pipeline showing the complete process from node generation through Poisson disk sampling, Delaunay triangulation, weight calculation, and difficulty adjustment to final level validation.}}{27}{figure.caption.58}%
\contentsline {figure}{\numberline {4.9}{\ignorespaces Optimized territory coloring algorithm flowchart showing the performance-optimized workflow from edge cutting to selective visual updates, highlighting the caching mechanisms and change detection strategies that reduce computational overhead.}}{29}{figure.caption.69}%
\addvspace {10\p@ }
\providecommand \tocbasic@end@toc@file {}\tocbasic@end@toc@file 
